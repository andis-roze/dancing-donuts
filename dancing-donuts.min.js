/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/raw-loader/dist/cjs.js!./src/shaders/basic/FragmentShader.glsl":
/*!*************************************************************************************!*\
  !*** ./node_modules/raw-loader/dist/cjs.js!./src/shaders/basic/FragmentShader.glsl ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("varying highp vec2 vTextureCoord;\n\nuniform highp sampler2D uSampler;\nuniform highp vec4 uColor;\n\nvoid main(void) {\n    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;\n}\n");

/***/ }),

/***/ "./node_modules/raw-loader/dist/cjs.js!./src/shaders/basic/VertexShader.glsl":
/*!***********************************************************************************!*\
  !*** ./node_modules/raw-loader/dist/cjs.js!./src/shaders/basic/VertexShader.glsl ***!
  \***********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ("attribute highp vec2 aPosition;\nattribute highp vec2 aTextureCoord;\n\nuniform highp mat3 uProjection;\nuniform highp mat3 uRotation;\n\nvarying highp vec2 vTextureCoord;\n\nvoid main() {\n    gl_Position = vec4((uProjection * uRotation * vec3(aPosition, 1)).xy, 0, 1);\n    vTextureCoord = aTextureCoord;\n}\n");

/***/ }),

/***/ "./src/DonutContainer2D.ts":
/*!*********************************!*\
  !*** ./src/DonutContainer2D.ts ***!
  \*********************************/
/*! exports provided: DonutContainer2D */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DonutContainer2D", function() { return DonutContainer2D; });
/* harmony import */ var _common_AbstractDonutContainer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common/AbstractDonutContainer */ "./src/common/AbstractDonutContainer.ts");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./src/utils.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


var DonutContainer2D = /** @class */ (function (_super) {
    __extends(DonutContainer2D, _super);
    function DonutContainer2D(props) {
        var _this = _super.call(this, props) || this;
        _this.donutHit = function (e) {
            var _a = e.detail, x = _a.x, y = _a.y;
            var _b = _this.donuts[x][y], donut = _b.donut, color = _b.color;
            donut.setColor(color);
            _this.spritesCtx.clearRect(x * _this.donutWidth + (x + 1) * _this.margin, y * _this.donutWidth + (y + 1) * _this.margin, _this.donutWidth, _this.donutWidth);
            _this.spritesCtx.drawImage(donut.getSprite(), 0, 0, _this.donutWidth, _this.donutWidth, x * _this.donutWidth + (x + 1) * _this.margin, y * _this.donutWidth + (y + 1) * _this.margin, _this.donutWidth, _this.donutWidth);
        };
        var ctx = _this.canvas.getContext("2d");
        if (!ctx) {
            throw new Error("Canvas 2d rendering context failed to initialise!");
        }
        _this.ctx = ctx;
        // TODO: Ugly hack. Try to come up with better approach to change 2D donut color
        // @ts-ignore
        window.addEventListener("donutHit", _this.donutHit);
        return _this;
    }
    DonutContainer2D.prototype.draw = function (step) {
        var _this = this;
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.donuts.forEach(function (row, x) {
            row.forEach(function (donutState, y) {
                donutState.rotationAngle = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["reduceAngle"])(donutState.rotationAngle + step * donutState.clockwise);
                _this.ctx.save();
                _this.ctx.translate(donutState.center.x, donutState.center.y);
                _this.ctx.rotate(donutState.rotationAngle);
                _this.ctx.drawImage(_this.sprites, x * _this.donutWidth + (x + 1) * _this.margin, y * _this.donutWidth + (y + 1) * _this.margin, _this.donutWidth, _this.donutWidth, x * _this.donutWidth - donutState.center.x + (x + 1) * _this.margin, y * _this.donutWidth - donutState.center.y + (y + 1) * _this.margin, _this.donutWidth, _this.donutWidth);
                _this.ctx.restore();
            });
        });
    };
    return DonutContainer2D;
}(_common_AbstractDonutContainer__WEBPACK_IMPORTED_MODULE_0__["AbstractDonutContainer"]));



/***/ }),

/***/ "./src/DonutContainer3D.ts":
/*!*********************************!*\
  !*** ./src/DonutContainer3D.ts ***!
  \*********************************/
/*! exports provided: DonutContainer3D */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DonutContainer3D", function() { return DonutContainer3D; });
/* harmony import */ var _common_AbstractDonutContainer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common/AbstractDonutContainer */ "./src/common/AbstractDonutContainer.ts");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./src/utils.ts");
/* harmony import */ var _shaders_basic_BasicShader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shaders/basic/BasicShader */ "./src/shaders/basic/BasicShader.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



var DonutContainer3D = /** @class */ (function (_super) {
    __extends(DonutContainer3D, _super);
    function DonutContainer3D(props) {
        var _this = _super.call(this, props) || this;
        _this.initialRotation = 0;
        var ctx = _this.canvas.getContext("webgl");
        if (!ctx) {
            throw new Error("Canvas WebGL rendering context failed to initialise!");
        }
        _this.ctx = ctx;
        _this.initCanvas(_this.canvas);
        _this.initShader();
        _this.initTextureCoords();
        _this.initPositionCoords();
        return _this;
    }
    DonutContainer3D.prototype.draw = function (step) {
        var _this = this;
        this.ctx.clearColor(0, 0, 0, 0);
        this.ctx.clear(this.ctx.COLOR_BUFFER_BIT);
        this.donuts.forEach(function (row, x) {
            row.forEach(function (donutState, y) {
                var color = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["splitHexColor"])(donutState.color);
                _this.ctx.uniform4f(_this.colorUniformLocation, color[0], color[1], color[2], 1);
                donutState.rotationAngle = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["reduceAngle"])(donutState.rotationAngle + step * donutState.clockwise);
                var translationMatrix = _utils__WEBPACK_IMPORTED_MODULE_1__["m3"].translation((2 * x + 1) * _this.donutOuterRadius, (2 * y + 1) * _this.donutOuterRadius);
                var undoTranslationMatrix = _utils__WEBPACK_IMPORTED_MODULE_1__["m3"].translation(-_this.donutOuterRadius, -_this.donutOuterRadius);
                var rotationMatrix = _utils__WEBPACK_IMPORTED_MODULE_1__["m3"].multiply(translationMatrix, _utils__WEBPACK_IMPORTED_MODULE_1__["m3"].rotation(donutState.rotationAngle));
                _this.ctx.uniformMatrix3fv(_this.rotationUniformLocation, false, _utils__WEBPACK_IMPORTED_MODULE_1__["m3"].multiply(rotationMatrix, undoTranslationMatrix));
                _this.ctx.drawArrays(_this.ctx.TRIANGLES, 0, 6);
            });
        });
    };
    DonutContainer3D.prototype.initCanvas = function (canvas) {
        var donutDiameter = 2 * this.donutOuterRadius;
        var canvasWidth = "" + this.donutCountX * donutDiameter;
        var canvasHeight = "" + this.donutCountY * donutDiameter;
        var ctx = canvas.getContext("webgl");
        if (!ctx) {
            throw new Error("Canvas 3D rendering context failed to initialise!");
        }
        this.canvas = canvas;
        this.canvas.setAttribute("width", canvasWidth);
        this.canvas.setAttribute("height", canvasHeight);
        this.ctx = ctx;
        this.ctx.viewport(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
        this.ctx.enable(this.ctx.BLEND);
        this.ctx.blendFunc(this.ctx.ONE, this.ctx.ONE);
        this.ctx.disable(this.ctx.DEPTH_TEST);
        this.ctx.clearColor(0, 0, 0, 0);
        // tslint:disable-next-line:no-bitwise
        this.ctx.clear(this.ctx.COLOR_BUFFER_BIT | this.ctx.DEPTH_BUFFER_BIT);
    };
    DonutContainer3D.prototype.initShader = function () {
        this.shader = new _shaders_basic_BasicShader__WEBPACK_IMPORTED_MODULE_2__["BasicShader"](this.ctx);
        this.shader.use();
        this.positionAttributeLocation = this.shader.getAttributeLocation("aPosition");
        this.projectionUniformLocation = this.shader.getUniformLocation("uProjection");
        this.rotationUniformLocation = this.shader.getUniformLocation("uRotation");
        this.colorUniformLocation = this.shader.getUniformLocation("uColor");
        this.textureCoordAttributeLocation = this.shader.getAttributeLocation("aTextureCoord");
        this.samplerUniformLocation = this.shader.getUniformLocation("uSampler");
    };
    DonutContainer3D.prototype.initTextureCoords = function () {
        var texture = this.ctx.createTexture();
        if (!texture) {
            throw new Error("Texture failed to initialise!");
        }
        this.texture = texture;
        var texCoordBuffer = this.ctx.createBuffer();
        var texCoords = [];
        if (!texCoordBuffer) {
            throw new Error("Texture coordinate buffer failed to initialise!");
        }
        this.texCoordBuffer = texCoordBuffer;
        this.ctx.bindBuffer(this.ctx.ARRAY_BUFFER, this.texCoordBuffer);
        // TODO: init tex coord buffer
        var margin = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["mapValueToInterval"])(this.margin, 0, this.canvas.width, 0, 1);
        var width = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["mapValueToInterval"])(this.donutWidth, 0, this.canvas.width, 0, 1);
        // for (let x = 0; x < this.donutCountX; x++) {
        //     for (let y = 0; y < this.donutCountY; y++) {
        texCoords.push(margin, margin, width, margin, margin, width, margin, width, width, margin, width, width);
        //     }
        // }
        this.ctx.bufferData(this.ctx.ARRAY_BUFFER, new Float32Array(texCoords), this.ctx.STATIC_DRAW);
        this.ctx.vertexAttribPointer(this.textureCoordAttributeLocation, 2, this.ctx.FLOAT, false, 0, 0);
        this.ctx.enableVertexAttribArray(this.textureCoordAttributeLocation);
        this.ctx.activeTexture(this.ctx.TEXTURE0);
        this.ctx.uniform1i(this.samplerUniformLocation, 0);
        this.ctx.uniform4f(this.colorUniformLocation, Math.random(), Math.random(), Math.random(), 1);
        this.ctx.bindTexture(this.ctx.TEXTURE_2D, this.texture);
        this.ctx.texImage2D(this.ctx.TEXTURE_2D, 0, this.ctx.RGBA, this.ctx.RGBA, this.ctx.UNSIGNED_BYTE, this.sprites);
        if (Object(_utils__WEBPACK_IMPORTED_MODULE_1__["isPowerOf2"])(this.sprites.width) && Object(_utils__WEBPACK_IMPORTED_MODULE_1__["isPowerOf2"])(this.sprites.height)) {
            this.ctx.generateMipmap(this.ctx.TEXTURE_2D);
        }
        else {
            this.ctx.texParameteri(this.ctx.TEXTURE_2D, this.ctx.TEXTURE_WRAP_S, this.ctx.CLAMP_TO_EDGE);
            this.ctx.texParameteri(this.ctx.TEXTURE_2D, this.ctx.TEXTURE_WRAP_T, this.ctx.CLAMP_TO_EDGE);
            this.ctx.texParameteri(this.ctx.TEXTURE_2D, this.ctx.TEXTURE_MIN_FILTER, this.ctx.LINEAR);
        }
    };
    DonutContainer3D.prototype.initPositionCoords = function () {
        var x1 = this.margin;
        var x2 = this.margin + this.donutWidth;
        var y1 = this.margin;
        var y2 = this.margin + this.donutWidth;
        var positionBuffer = this.ctx.createBuffer();
        if (!positionBuffer) {
            throw new Error("Position buffer failed to initialise!");
        }
        this.positionBuffer = positionBuffer;
        this.ctx.bindBuffer(this.ctx.ARRAY_BUFFER, this.positionBuffer);
        this.ctx.bufferData(this.ctx.ARRAY_BUFFER, new Float32Array([
            x1, y1,
            x2, y1,
            x1, y2,
            x1, y2,
            x2, y1,
            x2, y2,
        ]), this.ctx.STATIC_DRAW);
        this.ctx.vertexAttribPointer(this.positionAttributeLocation, 2, this.ctx.FLOAT, false, 2 * 4, 0);
        this.ctx.enableVertexAttribArray(this.positionAttributeLocation);
        this.ctx.uniformMatrix3fv(this.projectionUniformLocation, false, _utils__WEBPACK_IMPORTED_MODULE_1__["m3"].projection(this.canvas.clientWidth, this.canvas.clientHeight));
        this.ctx.uniformMatrix3fv(this.rotationUniformLocation, false, _utils__WEBPACK_IMPORTED_MODULE_1__["m3"].rotation(this.initialRotation));
    };
    return DonutContainer3D;
}(_common_AbstractDonutContainer__WEBPACK_IMPORTED_MODULE_0__["AbstractDonutContainer"]));



/***/ }),

/***/ "./src/common/AbstractDonutContainer.ts":
/*!**********************************************!*\
  !*** ./src/common/AbstractDonutContainer.ts ***!
  \**********************************************/
/*! exports provided: AbstractDonutContainer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AbstractDonutContainer", function() { return AbstractDonutContainer; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ "./src/utils.ts");
/* harmony import */ var _Donut__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Donut */ "./src/common/Donut.ts");


var AbstractDonutContainer = /** @class */ (function () {
    function AbstractDonutContainer(props) {
        var _this = this;
        this.donuts = [];
        this.border = 1;
        this.margin = 1;
        this.onClick = function (e) {
            if (!_this.canvasRect) {
                _this.canvasRect = _this.canvas.getBoundingClientRect();
            }
            var clickCoords = {
                x: e.pageX - _this.canvasRect.left,
                y: e.pageY - _this.canvasRect.top,
            };
            var donutCoords = _this.getDonutCoords(clickCoords);
            var donutState = _this.donuts[donutCoords.x][donutCoords.y];
            if (_this.isDonutHit(donutState, clickCoords)) {
                donutState.clockwise = -1 * donutState.clockwise;
                donutState.color = Object(_utils__WEBPACK_IMPORTED_MODULE_0__["getRandomColor"])();
                // TODO: Ugly hack. Try to come up with better approach to change 2D donut color
                window.dispatchEvent(new CustomEvent("donutHit", { detail: { x: donutCoords.x, y: donutCoords.y } }));
            }
        };
        this.canvas = props.canvas;
        this.canvasRect = this.canvas.getBoundingClientRect();
        this.donutCountX = props.donutCountX || 20;
        this.donutCountY = props.donutCountY || 20;
        this.donutOuterRadius = props.donutOuterRadius || 25;
        this.donutInnerRadius = props.donutInnerRadius || 10;
        this.donutWidth = 2 * (this.donutOuterRadius + this.border);
        var canvasWidth = "" + (this.donutCountX * this.donutWidth
            + this.donutCountX * this.margin);
        var canvasHeight = "" + (this.donutCountY * this.donutWidth
            + this.donutCountY * this.margin);
        this.canvas.setAttribute("width", canvasWidth);
        this.canvas.setAttribute("height", canvasHeight);
        this.canvas.addEventListener("click", this.onClick);
        // this.canvas.addEventListener("touchend", this.onClick);
        this.sprites = document.createElement("canvas");
        this.sprites.setAttribute("width", canvasWidth);
        this.sprites.setAttribute("height", canvasHeight);
        var spritesCtx = this.sprites.getContext("2d");
        if (!spritesCtx) {
            throw Error("Sprite canvas 2d rendering context failed to initialise!");
        }
        this.spritesCtx = spritesCtx;
        this.initDonutState();
    }
    AbstractDonutContainer.prototype.destructor = function () {
        this.canvas.removeEventListener("click", this.onClick);
        // this.canvas.removeEventListener("touchend", this.onClick);
        delete this.canvasRect;
        delete this.ctx;
        delete this.canvas;
        delete this.donuts;
        delete this.sprites;
        delete this.spritesCtx;
        delete this.donutCountX;
        delete this.donutCountY;
        delete this.donutInnerRadius;
        delete this.donutOuterRadius;
        delete this.border;
        delete this.donutWidth;
    };
    AbstractDonutContainer.prototype.initDonutState = function () {
        for (var x = 0; x < this.donutCountX; x++) {
            this.donuts[x] = [];
            for (var y = 0; y < this.donutCountY; y++) {
                var color = Object(_utils__WEBPACK_IMPORTED_MODULE_0__["getRandomColor"])();
                var rotationAngle = 0;
                var startAngle = Object(_utils__WEBPACK_IMPORTED_MODULE_0__["getRandomArbitrary"])(0, 1.75 * Math.PI);
                var segmentAngle = Object(_utils__WEBPACK_IMPORTED_MODULE_0__["getRandomArbitrary"])(Math.PI / 2, 1.75 * Math.PI);
                var endAngle = Object(_utils__WEBPACK_IMPORTED_MODULE_0__["reduceAngle"])(startAngle + segmentAngle);
                var donut = new _Donut__WEBPACK_IMPORTED_MODULE_1__["Donut"]({
                    color: color,
                    startAngle: startAngle,
                    endAngle: endAngle,
                    innerRadius: this.donutInnerRadius,
                    outerRadius: this.donutOuterRadius,
                    border: this.border,
                });
                this.donuts[x][y] = {
                    donut: donut,
                    color: color,
                    clockwise: Object(_utils__WEBPACK_IMPORTED_MODULE_0__["getRandomDirection"])(),
                    rotationAngle: rotationAngle,
                    startAngle: startAngle,
                    endAngle: endAngle,
                    segmentAngle: segmentAngle,
                    center: {
                        x: (2 * x + 1) * this.donutWidth / 2 + (x + 1) * this.margin,
                        y: (2 * y + 1) * this.donutWidth / 2 + (y + 1) * this.margin,
                    },
                };
                this.spritesCtx.drawImage(donut.getSprite(), 0, 0, this.donutWidth, this.donutWidth, x * this.donutWidth + (x + 1) * this.margin, y * this.donutWidth + (y + 1) * this.margin, this.donutWidth, this.donutWidth);
            }
        }
    };
    AbstractDonutContainer.prototype.getDonutCoords = function (coords) {
        return {
            x: Math.floor(coords.x / (this.donutWidth + this.margin)),
            y: Math.floor(coords.y / (this.donutWidth + this.margin)),
        };
    };
    AbstractDonutContainer.prototype.isDonutHit = function (donutState, clickCoords) {
        var center = donutState.center, rotationAngle = donutState.rotationAngle, segmentAngle = donutState.segmentAngle;
        var clickDistance = Object(_utils__WEBPACK_IMPORTED_MODULE_0__["getDistance"])(center, clickCoords);
        var clickAngle = Object(_utils__WEBPACK_IMPORTED_MODULE_0__["atan2Arc"])(Object(_utils__WEBPACK_IMPORTED_MODULE_0__["getAngle"])(center, clickCoords));
        var startAngle = donutState.startAngle, endAngle = donutState.endAngle;
        startAngle = Object(_utils__WEBPACK_IMPORTED_MODULE_0__["reduceAngle"])(startAngle + rotationAngle + 2 * Math.PI);
        endAngle = Object(_utils__WEBPACK_IMPORTED_MODULE_0__["reduceAngle"])(endAngle + rotationAngle + 2 * Math.PI);
        var clickToEndSegmentAngle = Object(_utils__WEBPACK_IMPORTED_MODULE_0__["reduceAngle"])(endAngle + 2 * Math.PI - clickAngle);
        return this.donutInnerRadius <= clickDistance
            && this.donutOuterRadius >= clickDistance
            && clickToEndSegmentAngle >= 0
            && clickToEndSegmentAngle <= segmentAngle;
    };
    return AbstractDonutContainer;
}());



/***/ }),

/***/ "./src/common/Donut.ts":
/*!*****************************!*\
  !*** ./src/common/Donut.ts ***!
  \*****************************/
/*! exports provided: Donut */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Donut", function() { return Donut; });
var Donut = /** @class */ (function () {
    function Donut(props) {
        var _this = this;
        this.getSprite = function () { return _this.canvas; };
        this.setColor = function (color) {
            _this.color = color;
            return _this.draw();
        };
        this.canvas = document.createElement("canvas");
        this.border = props.border;
        var ctx = this.canvas.getContext("2d");
        var width = 2 * (props.outerRadius + this.border);
        if (!ctx) {
            throw new Error("Canvas 2d rendering context failed to initialise!");
        }
        this.ctx = ctx;
        this.canvas.width = width;
        this.canvas.height = width;
        this.color = props.color;
        this.startAngle = props.startAngle;
        this.endAngle = props.endAngle;
        this.innerRadius = props.innerRadius;
        this.outerRadius = props.outerRadius;
        this.draw();
    }
    Donut.prototype.draw = function () {
        this.ctx.clearRect(-1, -1, this.canvas.width + 1, this.canvas.height + 1);
        // Reset current transformation matrix to the identity matrix
        this.ctx.setTransform(1, 0, 0, 1, 0, 0);
        this.ctx.strokeStyle = "black";
        this.ctx.fillStyle = this.color;
        this.ctx.lineWidth = this.border;
        this.ctx.beginPath();
        this.ctx.translate(this.border, this.border);
        // Outer arc: clockwise
        this.ctx.arc(this.outerRadius, this.outerRadius, this.outerRadius, this.startAngle, this.endAngle, false);
        // Inner arc: counter clockwise
        this.ctx.arc(this.outerRadius, this.outerRadius, this.innerRadius, this.endAngle, this.startAngle, true);
        this.ctx.closePath();
        this.ctx.fill();
        this.ctx.stroke();
        return this.canvas;
    };
    return Donut;
}());



/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _DonutContainer2D__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DonutContainer2D */ "./src/DonutContainer2D.ts");
/* harmony import */ var _DonutContainer3D__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DonutContainer3D */ "./src/DonutContainer3D.ts");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ "./src/utils.ts");



var ContainerType;
(function (ContainerType) {
    ContainerType["CONTEXT_2D"] = "2D";
    ContainerType["CONTEXT_3D"] = "3D";
})(ContainerType || (ContainerType = {}));
var containerMap = {
    "2D": _DonutContainer2D__WEBPACK_IMPORTED_MODULE_0__["DonutContainer2D"],
    "3D": _DonutContainer3D__WEBPACK_IMPORTED_MODULE_1__["DonutContainer3D"],
};
document.addEventListener("DOMContentLoaded", function () {
    var fpsCanvas = document.getElementById("fpsCanvas");
    var fpsCtx = fpsCanvas.getContext("2d");
    var canvas;
    var donutContainer;
    var canvasContainer = document.getElementById("canvasContainer");
    var animationFrameId = 0;
    function getText(fun) {
        return "Switch to " + fun;
    }
    function updateFps(fps) {
        fpsCtx.font = "25px serif";
        fpsCtx.clearRect(0, 0, fpsCanvas.width, fpsCanvas.height);
        fpsCtx.fillText(fps, 0, 25);
    }
    function prepareCanvas() {
        if (!canvasContainer) {
            throw new Error("Missing canvas parent container!");
        }
        if (canvas && donutContainer) {
            donutContainer.destructor();
            canvasContainer.removeChild(canvas);
            donutContainer = null;
        }
        canvas = document.createElement("canvas");
        canvas.classList.add("donut-canvas");
        canvasContainer.appendChild(canvas);
    }
    function start(containerType, donutCount) {
        if (donutCount === void 0) { donutCount = 20; }
        var radiansPerSecond = Math.PI / 4;
        prepareCanvas();
        donutContainer = new containerMap[containerType]({
            canvas: canvas,
            donutCountX: donutCount,
            donutCountY: donutCount
        });
        run(radiansPerSecond);
    }
    function run(radiansPerSecond) {
        var fpsUpdateInterval = 1000;
        var lastRender = performance.now();
        var lastFpsUpdate = lastRender;
        var renderLoop = function (time) {
            if (!donutContainer) {
                throw new Error("Missing donut container!");
            }
            var delta = (time - lastRender) / 1000;
            var step = radiansPerSecond * delta;
            if (time - lastFpsUpdate >= fpsUpdateInterval) {
                var fps = 1 / delta;
                updateFps(Object(_utils__WEBPACK_IMPORTED_MODULE_2__["roundToDecimals"])(fps, 3).toString() + " FPS");
                lastFpsUpdate = time;
            }
            lastRender = time;
            donutContainer.draw(step);
            animationFrameId = window.requestAnimationFrame(renderLoop);
        };
        animationFrameId = window.requestAnimationFrame(renderLoop);
    }
    var defaultContainer = ContainerType.CONTEXT_2D;
    var toggleButton = document.getElementById("toggleButton");
    var elDonutCount = document.getElementById("donutCount");
    function toggleButtonClick(e) {
        cancelAnimationFrame(animationFrameId);
        if (toggleButton.innerText === getText(ContainerType.CONTEXT_2D)) {
            toggleButton.innerText = getText(ContainerType.CONTEXT_3D);
            start(ContainerType.CONTEXT_2D, parseInt(elDonutCount.value, 10));
        }
        else {
            toggleButton.innerText = getText(ContainerType.CONTEXT_2D);
            start(ContainerType.CONTEXT_3D, parseInt(elDonutCount.value, 10));
        }
    }
    toggleButton.innerText = getText(defaultContainer === ContainerType.CONTEXT_2D
        ? ContainerType.CONTEXT_3D
        : ContainerType.CONTEXT_2D);
    toggleButton.addEventListener("click", toggleButtonClick);
    elDonutCount.addEventListener("change", function (e) {
        if (toggleButton.innerText === getText(ContainerType.CONTEXT_2D)) {
            start(ContainerType.CONTEXT_3D, e.target.value);
        }
        else {
            start(ContainerType.CONTEXT_2D, e.target.value);
        }
    });
    start(defaultContainer);
});


/***/ }),

/***/ "./src/shaders/AbstractShader.ts":
/*!***************************************!*\
  !*** ./src/shaders/AbstractShader.ts ***!
  \***************************************/
/*! exports provided: AbstractShader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AbstractShader", function() { return AbstractShader; });
var AbstractShader = /** @class */ (function () {
    function AbstractShader(name, ctx) {
        this.attributes = {};
        this.uniforms = {};
        this.name = name;
        this.ctx = ctx;
        var program = this.ctx.createProgram();
        if (!program) {
            throw new Error("Shader program failed to initialise!");
        }
        this.program = program;
    }
    AbstractShader.prototype.getName = function () {
        return this.name;
    };
    AbstractShader.prototype.use = function () {
        this.ctx.useProgram(this.program);
    };
    AbstractShader.prototype.getAttributeLocation = function (name) {
        if (this.attributes[name] === undefined) {
            throw new Error("Unable to find attribute named \"" + name + "\" in shader named " + this.name);
        }
        return this.attributes[name];
    };
    AbstractShader.prototype.getUniformLocation = function (name) {
        if (this.uniforms[name] === undefined) {
            throw new Error("Unable to find uniform named \"" + name + "\" in shader named " + this.name);
        }
        return this.uniforms[name];
    };
    AbstractShader.prototype.load = function (vertexSource, fragmentSource) {
        var vertexShader = this.loadShader(vertexSource, this.ctx.VERTEX_SHADER);
        var fragmentShader = this.loadShader(fragmentSource, this.ctx.FRAGMENT_SHADER);
        this.createProgram(vertexShader, fragmentShader);
        this.getAttributes();
        this.getUniforms();
    };
    AbstractShader.prototype.loadShader = function (source, shaderType) {
        var shader = this.ctx.createShader(shaderType);
        if (!shader) {
            throw new Error((shaderType === this.ctx.VERTEX_SHADER
                ? "Vertex"
                : "Fragment") + " shader failed to initialise!");
        }
        this.ctx.shaderSource(shader, source);
        this.ctx.compileShader(shader);
        var error = this.ctx.getShaderInfoLog(shader).trim();
        if (error !== "") {
            throw new Error("Error compiling shader \"" + this.name + "\": " + error);
        }
        return shader;
    };
    AbstractShader.prototype.createProgram = function (vertexShader, fragmentShader) {
        this.ctx.attachShader(this.program, vertexShader);
        this.ctx.attachShader(this.program, fragmentShader);
        this.ctx.linkProgram(this.program);
        var error = this.ctx.getProgramInfoLog(this.program).trim();
        if (error !== "") {
            throw new Error("Error linking shader \"" + this.name + "\": " + error);
        }
    };
    AbstractShader.prototype.getAttributes = function () {
        if (!this.program) {
            throw new Error("Shader program failed to initialise!");
        }
        var attributeCount = this.ctx.getProgramParameter(this.program, this.ctx.ACTIVE_ATTRIBUTES);
        for (var i = 0; i < attributeCount; ++i) {
            var info = this.ctx.getActiveAttrib(this.program, i);
            if (!info) {
                break;
            }
            this.attributes[info.name] = this.ctx.getAttribLocation(this.program, info.name);
        }
    };
    AbstractShader.prototype.getUniforms = function () {
        var uniformCount = this.ctx.getProgramParameter(this.program, this.ctx.ACTIVE_UNIFORMS);
        for (var i = 0; i < uniformCount; ++i) {
            var info = this.ctx.getActiveUniform(this.program, i);
            if (!info) {
                break;
            }
            var uniformLocation = this.ctx.getUniformLocation(this.program, info.name);
            if (!uniformLocation) {
                break;
            }
            this.uniforms[info.name] = uniformLocation;
        }
    };
    return AbstractShader;
}());



/***/ }),

/***/ "./src/shaders/basic/BasicShader.ts":
/*!******************************************!*\
  !*** ./src/shaders/basic/BasicShader.ts ***!
  \******************************************/
/*! exports provided: BasicShader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BasicShader", function() { return BasicShader; });
/* harmony import */ var raw_loader_VertexShader_glsl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! raw-loader!./VertexShader.glsl */ "./node_modules/raw-loader/dist/cjs.js!./src/shaders/basic/VertexShader.glsl");
/* harmony import */ var raw_loader_FragmentShader_glsl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! raw-loader!./FragmentShader.glsl */ "./node_modules/raw-loader/dist/cjs.js!./src/shaders/basic/FragmentShader.glsl");
/* harmony import */ var _AbstractShader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../AbstractShader */ "./src/shaders/AbstractShader.ts");
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();



var BasicShader = /** @class */ (function (_super) {
    __extends(BasicShader, _super);
    function BasicShader(ctx) {
        var _this = _super.call(this, "basic", ctx) || this;
        _this.load(raw_loader_VertexShader_glsl__WEBPACK_IMPORTED_MODULE_0__["default"], raw_loader_FragmentShader_glsl__WEBPACK_IMPORTED_MODULE_1__["default"]);
        return _this;
    }
    return BasicShader;
}(_AbstractShader__WEBPACK_IMPORTED_MODULE_2__["AbstractShader"]));



/***/ }),

/***/ "./src/utils.ts":
/*!**********************!*\
  !*** ./src/utils.ts ***!
  \**********************/
/*! exports provided: roundToDecimals, mapValueToInterval, splitHexColor, getRandomColor, getAngle, atan2Arc, getDistance, reduceAngle, getRandomArbitrary, getRandomDirection, isPowerOf2, m3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "roundToDecimals", function() { return roundToDecimals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mapValueToInterval", function() { return mapValueToInterval; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "splitHexColor", function() { return splitHexColor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRandomColor", function() { return getRandomColor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAngle", function() { return getAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "atan2Arc", function() { return atan2Arc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDistance", function() { return getDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reduceAngle", function() { return reduceAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRandomArbitrary", function() { return getRandomArbitrary; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRandomDirection", function() { return getRandomDirection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isPowerOf2", function() { return isPowerOf2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m3", function() { return m3; });
function roundToDecimals(value, decimals) {
    return Math.floor(value * Math.pow(10, decimals)) / Math.pow(10, decimals);
}
function mapValueToInterval(val, fromStart, fromEnd, toStart, toEnd) {
    return (val - fromStart) * (toEnd - toStart) / (fromEnd - fromStart) + toStart;
}
function splitHexColor(color) {
    var intColors = [
        parseInt(color.substring(1, 3), 16),
        parseInt(color.substring(3, 5), 16),
        parseInt(color.substring(5), 16),
    ];
    return intColors.map(function (c) { return mapValueToInterval(c, 0, 255, 0, 1); });
}
function getRandomColor() {
    var digits = "0123456789ABCDEF";
    var color = "#";
    for (var i = 0; i < 6; i++) {
        color += digits[Math.floor(Math.random() * 16)];
    }
    return color;
}
function getAngle(center, point) {
    return Math.atan2(point.y - center.y, point.x - center.x);
}
function atan2Arc(angle) {
    return angle < 0 ? 2 * Math.PI + angle : angle;
}
function getDistance(p1, p2) {
    return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
}
function reduceAngle(angle) {
    return angle % (2 * Math.PI);
}
function getRandomArbitrary(min, max) {
    return Math.random() * (max - min) + min;
}
function getRandomDirection() {
    return getRandomArbitrary(-1, 1) >= 0 ? 1 : -1;
}
function isPowerOf2(value) {
    // tslint:disable no-bitwise
    return (value & (value - 1)) === 0;
}
var m3 = {
    identity: function () {
        return [
            1, 0, 0,
            0, 1, 0,
            0, 0, 1,
        ];
    },
    projection: function (width, height) {
        return [
            2.0 / width, 0.0, 0.0,
            0.0, -2.0 / height, 0.0,
            -1.0, 1.0, 1.0
        ];
    },
    translation: function (tx, ty) {
        return [
            1, 0, 0,
            0, 1, 0,
            tx, ty, 1,
        ];
    },
    rotation: function (angleInRadians) {
        var c = Math.cos(angleInRadians);
        var s = Math.sin(angleInRadians);
        return [
            c, -s, 0,
            s, c, 0,
            0, 0, 1,
        ];
    },
    scaling: function (sx, sy) {
        return [
            sx, 0, 0,
            0, sy, 0,
            0, 0, 1,
        ];
    },
    multiply: function (a, b) {
        var a00 = a[0 * 3 + 0];
        var a01 = a[0 * 3 + 1];
        var a02 = a[0 * 3 + 2];
        var a10 = a[1 * 3 + 0];
        var a11 = a[1 * 3 + 1];
        var a12 = a[1 * 3 + 2];
        var a20 = a[2 * 3 + 0];
        var a21 = a[2 * 3 + 1];
        var a22 = a[2 * 3 + 2];
        var b00 = b[0 * 3 + 0];
        var b01 = b[0 * 3 + 1];
        var b02 = b[0 * 3 + 2];
        var b10 = b[1 * 3 + 0];
        var b11 = b[1 * 3 + 1];
        var b12 = b[1 * 3 + 2];
        var b20 = b[2 * 3 + 0];
        var b21 = b[2 * 3 + 1];
        var b22 = b[2 * 3 + 2];
        return [
            b00 * a00 + b01 * a10 + b02 * a20,
            b00 * a01 + b01 * a11 + b02 * a21,
            b00 * a02 + b01 * a12 + b02 * a22,
            b10 * a00 + b11 * a10 + b12 * a20,
            b10 * a01 + b11 * a11 + b12 * a21,
            b10 * a02 + b11 * a12 + b12 * a22,
            b20 * a00 + b21 * a10 + b22 * a20,
            b20 * a01 + b21 * a11 + b22 * a21,
            b20 * a02 + b21 * a12 + b22 * a22,
        ];
    }
};


/***/ })

/******/ });
//# sourceMappingURL=dancing-donuts.min.js.map